import { Bool, Field, AsFieldElements, Pickles } from '../snarky';
export { Proof, Program };
export { CompiledTag, sortMethodArguments, getPreviousProofsForProver, MethodInterface, picklesRuleFromFunction, compileProgram, };
declare class Proof<T> {
    static publicInputType: AsFieldElements<any>;
    static tag: () => {
        name: string;
    };
    publicInput: T;
    proof: RawProof;
    shouldVerify: Bool;
    verify(): void;
    verifyIf(condition: Bool): void;
    toString(): string;
    constructor({ proof, publicInput }: {
        proof: RawProof;
        publicInput: T;
    });
}
declare type RawProof = unknown;
declare type CompiledTag = unknown;
declare let CompiledTag: {
    get(tag: any): CompiledTag | undefined;
    store(tag: any, compiledTag: CompiledTag): void;
};
declare function Program<PublicInputType extends AsFieldElements<any>, Types extends {
    [I in string]: Tuple<PrivateInput>;
}>({ publicInput: publicInputType, methods, }: {
    publicInput: PublicInputType;
    methods: {
        [I in keyof Types]: Method<InferInstance<PublicInputType>, Types[I]>;
    };
}): {
    name: string;
    compile: () => Promise<void>;
} & {
    [I in keyof Types]: Prover<InferInstance<PublicInputType>, Types[I]>;
};
declare function sortMethodArguments(programName: string, methodName: string, privateInputs: unknown[]): MethodInterface;
declare function getPreviousProofsForProver(methodArgs: any[], { allArgs, proofArgs }: MethodInterface): Pickles.ProofWithPublicInput[];
declare type MethodInterface = {
    methodName: string;
    witnessArgs: AsFieldElements<unknown>[];
    proofArgs: Subclass<typeof Proof>[];
    allArgs: {
        type: 'witness' | 'proof';
        index: number;
    }[];
};
declare function compileProgram(publicInputType: AsFieldElements<any>, methodIntfs: MethodInterface[], methods: ((...args: any) => void)[], proofSystemTag: {
    name: string;
}, additionalContext?: {
    self: any;
} | undefined): {
    getVerificationKeyArtifact: () => {
        data: string;
        hash: string;
    };
    provers: Pickles.Prover[];
    verify: (publicInput: Field[], proof: unknown) => Promise<boolean>;
    tag: unknown;
};
declare function picklesRuleFromFunction(publicInputType: AsFieldElements<any>, func: (...args: unknown[]) => void, proofSystemTag: {
    name: string;
}, { methodName, witnessArgs, proofArgs, allArgs }: MethodInterface): Pickles.Rule;
declare type Tuple<T> = [T, ...T[]] | [];
declare type InferInstance<T> = T extends new (...args: any) => any ? InstanceType<T> : never;
declare type TupleToInstances<T> = {
    [I in keyof T]: InferInstance<T[I]>;
};
declare type Subclass<Class extends new (...args: any) => any> = (new (...args: any) => InstanceType<Class>) & {
    [K in keyof Class]: Class[K];
} & {
    prototype: InstanceType<Class>;
};
declare type PrivateInput = AsFieldElements<any> | Subclass<typeof Proof>;
declare type Method<PublicInput, Args extends Tuple<PrivateInput>> = {
    privateInput: Args;
    method(publicInput: PublicInput, ...args: TupleToInstances<Args>): void;
};
declare type Prover<PublicInput, Args extends Tuple<PrivateInput>> = (publicInput: PublicInput, ...args: TupleToInstances<Args>) => Promise<Proof<PublicInput>>;
